					;hide apply as 'apply-primitive-procedure'
(define apply-in-underlying-scheme apply)

;;utilities
(define (showtag exp)
  (car tag))
(define (tagged-list? exp tag)
;;  (log "tagged-list? ---- if pair")
;;(log (pair? exp))
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
(define (log msg)
  (display "log:")
  (display msg)
  (newline))

					;dispatch query
(define (variable? exp)
  (symbol? exp))
(define (quote? exp)
  (tagged-list? exp `quote))
(define (application? exp)
  (pair? exp))
(define (assignment? exp)
  (tagged-list? exp `set!))
(define (definition? exp)
  (tagged-list? exp `define))
(define (if? exp)
  (tagged-list? exp `if))
(define (cond? exp)
  (tagged-list? exp 'cond))
(define (begin? exp)
  (tagged-list? exp `begin))
(define (unassign? exp)
  (eq? exp '*unassigned*))
(define (self-evaluating? exp)
  (cond ((number? exp) #t)
	((string? exp) #t)
	((unassign? exp) #t)
	(else #f)))
(define (lambda? exp)
  (tagged-list? exp `lambda))

					;eval quotation
(define (text-of-quotation exp)
  (cdr exp))

					;eval conditional sentence
(define (cond-clauses exp)
  (cdr exp))
(define (cond-predicate clause)
  (car clause))
(define (cond-action clause)
  (cdr clause))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (expand-clauses clauses)
  (if (null? clauses)
      `false
      (let ((first (car clauses))
	    (rest (cdr clauses)))
	(if (not (cond-else-clause? first))
	    (make-if (cond-predicate first)
		     (seq->exp (cond-action first))
		     (expand-clauses rest))
	    (seq->exp (cond-action first))))))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))
(define (eval-cond exp env)
  (eval (cond->if exp) env))

					;eval assignment
(define (assignment-variable exp)
  (cadr exp))
(define (assignment-value exp)
  (caddr exp))
(define (eval-assignment exp env)
  (log "assignment:")
  (log exp)
  (set-variable-value! (assignment-variable exp)
		       (eval (assignment-value exp) env)
		       env)
  `ok)
					;internal definition
(define (append-to-list args lists)
  (cons args lists))
(define (scan-out-defines lambda-exp)
  (log "scan-out-defs")
  (log lambda-exp)
  (define (scan rest args vals)
    (cond ((null? rest) (make-let-internal-def args vals rest))
	  ((definition? (car rest)) (scan (cdr rest) (append-to-list (definition-variable (car rest)) args) (append-to-list (definition-value (car rest)) vals)))
	  (else (make-let-internal-def args vals rest))
	  ))
  (scan lambda-exp `() `()))
(define (make-let-internal-def args vals body)
  (log "make-let-internal-def:")
  (log "args-vals:")
  (log (list args vals))
  (log "body:")
  (log body)
  (if (null? args)
      body
      (let ((args-list (map (lambda (x) (list x `*unassigned*)) args))
	    (vals-list (map (lambda (x y) (list `set! x y)) args vals)))
	(list (append (list `let args-list) (append vals-list body))))))


					;eval definition

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (begin
	(log "make lambda")
	(log (make-lambda (cdadr exp) (cddr exp)))
	(make-lambda (cdadr exp) (cddr exp)))))


(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
    (eval (definition-value exp) env)
    env)
  ;;(display (first-frame env))
  `ok)

					;eval lambda:
(define (lambda-parameters exps)
  (cadr exps))
(define (lambda-body exps)
  (cddr exps))
(define (make-lambda para body)
  (cons `lambda (cons para body)))
(define (lambda? exp)
  (tagged-list? exp `lambda))

					;eval if
(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
(define (if? exp)
  (tagged-list? exp `if))
(define (if-predicate exp)
  (cadr exp))
(define (if-consequent exp)
  (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      `false));;no alternative situation
(define (make-if predicate consequent alternative)
  (list `if predicate consequent alternative))
					;eval let
(define (let? exp)
  (tagged-list? exp `let))
(define (let-content exp)
  (cdr exp))
(define (var-val-list-to-args-vals exp)
  (list (map (lambda (exp) (car exp)) exp)
	(map (lambda (exp) (cadr exp)) exp)))
(define (eval-let exp env)
  (let ((args-vals (var-val-list-to-args-vals (car exp)))
	(body (cdr exp)))
    (myApply (eval (make-lambda (car args-vals) body) env) (list-of-value (cadr args-vals) env))))

					;eval sequent setence
(define (begin-action exp)
  (cdr exp))
(define (last-exp? exp)
  (null? (cdr exp)))
(define (first-exp exp)
  (car exp))
(define (rest-exp exp)
  (cdr exp))
(define (make-begin seq)
  (cons `begin seq))
(define (seq->exp seq);;used in cond sentence where no begin tagged
  (cond 
   ((null? seq) seq)
   ((last-exp? seq) (first-exp seq))
   (else (make-begin seq))
   ))
(define (eval-sequence exp env)
  (log "-------------SEPERATE-----------")
  (log "eval sequence")
  (log exp)
  (cond ((last-exp? exp) (eval (first-exp exp) env))
	(else (eval (first-exp exp) env)
	      (eval-sequence (rest-exp exp) env))))

					;eval applications:
(define (operator exp)
  (car exp))
(define (operand exp)
  (cdr exp))
(define (first-operand ops)
  (car ops))
(define (rest-operand ops)
  (cdr ops))

					;eval procedure (apply)

(define (primitive-procedure? exp)
  (tagged-list? exp `primitive))
(define (make-procedure para body env)
  (begin
    ;;(log "make procedure:")
    ;;(log  (list `procedure para body env))
    (list `procedure para (scan-out-defines body) env)))
(define (compound-procedure? exp)
  (tagged-list? exp `procedure))
(define (procedure-parameters exp)
  (cadr exp))
(define (procedure-body exp)
  (caddr exp))
(define (procedure-environment exp)
  (cadddr exp))
					;apply
(define (myApply proc args)
  ;;(log "apply proc:")
  ;;(log (car proc))
  (cond ((primitive-procedure? proc)
	 (apply-primitive-procedure proc args))
	((compound-procedure? proc)
	 (log "apply compound procedure--PROC BODY:")
	 (log (procedure-body proc))
	 (log "apply compound procedure--PROC ARGS:")
	 (log (procedure-parameters proc))
	 (eval-sequence (procedure-body proc)
			(extend-environment (procedure-parameters proc)
					    args
					    (procedure-environment proc))))
	(else
	 (error "UNKNOWN proc type--APPLY" (display proc))))
  )
(define (list-of-value args env)
  (map (lambda (arg) (eval arg env)) args))
					;define boolean 
(define (true? x)
  (not (eq? x #f)))
(define (false? x)
  (eq? x #f))
					;environment
(define (frame-variables frame)
  (car frame))
(define (frame-values frame)
  (cdr frame))
(define (make-frame vars vals)
  (cons vars vals))
(define (enclosing-environment env)
  (cdr env))
(define (first-frame env)
  (car env))
(define the-empty-environment `())
(define (add-binding var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame)))
  )
(define (lookup-variable-value var env)
  (define (loop-env env)
    (define (scan vars vals)
      (cond ((null? vars) (loop-env (enclosing-environment env)))
	    ((eq? (car vars) var) (car vals))
	    ((eq? (car vars) `*unassigned*) (error "value unassigned -- Internal Define -- from lookup-variable-value"))
	    (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
	(error "No such var on environment--lookup-var-val" var)
	(scan (frame-variables (first-frame env)) (frame-values (first-frame env)))))
  (loop-env env))

(define (set-variable-value! var val env)
  (define (loop-env env)
    (define (scan vars vals)
      (cond ((null? vars) (loop-env (enclosing-environment env)))
	    ((eq? (car vars) var) (set-car! vals val))
	    (else (scan (cdr vars vals)))))
    (if (eq? env the-empty-environment)
	(error "No such var on given environment--set-var-val!" var)
	(scan (frame-variables (first-frame env)) (frame-values (first-frame env)))))
  (loop-env env))
(define (define-variable! var val env)
  (begin
    (define (scan vars vals)
      (cond ((null? vars) (add-binding var val (first-frame env)))
	    ((eq? (car vars) var) (set-car! vals val))
	    (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables (first-frame env)) (frame-values (first-frame env))))
  )


(define (extend-environment vars vals env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) env)
      (if (< (length vars) (length vals))
	  (error "too many arguments supplied" vars vals)
	  (error "Too few args supplied" vars vals))
      )
  )




					;environment setup
(define (setup-environment)
  (let ((init-environment
	 (extend-environment (primitive-procedure-names)
			     (primitive-procedure-objects)
			     the-empty-environment)))
    (define-variable! `true #t init-environment)
    (define-variable! `false #f init-environment)
    init-environment))
(define primitive-procedures
  (list (list `car car)
	(list `+ +)
	(list `= =)
	(list `- -)
	(list `* *)
	(list `/ /)
	;(list `or or)
	(list `> >)
	(list `< <)
	(list `cdr cdr)
	(list `list list)
	(list `cons cons)
	(list `null? null?)
	))
(define (primitive-procedure-names)
  (map car primitive-procedures))
(define (primitive-procedure-objects)
  (map (lambda (proc) (list `primitive (cadr proc)))
       primitive-procedures))
(define (apply-primitive-procedure proc args)
  (log "apply primitive procedure:")
  (apply-in-underlying-scheme
   (primitive-implementation proc)
   args))
(define global-environment (setup-environment))
(define (primitive-implementation proc)
  (cadr proc))
					;evaluator
(define (eval exp env)
  (log "---------------SEPERATE---------------")
  (log "eval content:")
  (log exp)
  (cond 
   ((self-evaluating? exp) exp)
   ((variable? exp) (lookup-variable-value exp env))
   ((quote? exp) (text-of-quotation exp))
   ((assignment? exp) (eval-assignment exp env))
   ((definition? exp) (eval-definition exp env))
   ((if? exp) (eval-if exp env))
   ((cond? exp) (eval-cond exp env))
   ((lambda? exp)
    (make-procedure (lambda-parameters exp)
		    (lambda-body exp)
		    env)
    )
   ((begin? exp)
    (eval-sequence (begin-action exp) env))
   ((let? exp)
    (eval-let (let-content exp) env))
   ((application? exp)
    (myApply
     (eval (operator exp) env)
     (list-of-value (operand exp) env)))
   (else
    (error "Unknown expression type--EVAL" exp))
   ))
					;input prompt
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval output:")
(define (prompt-for-input string)
  (newline)
  (newline)
  (display string)
  (newline))
(define (announce-output string )
  (newline)
  (display string)
  (newline))
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (display input)
    (newline)
    (let ((output (eval input global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))

(define (user-print object)
  (if (compound-procedure? object)
      (display (list `compound-procedure
		     (procedure-parameters object)
		     (procedure-body object)
		     `procedure env))
      (display object)
      ))

